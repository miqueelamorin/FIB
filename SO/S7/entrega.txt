Pregunta 55.
    2 - ./es1 > /dev/pts/0
    3 - ./es1 | ./es1

    La v1 ejecuta 1420 llamadas ya que lee cada char.
    La v2 ejecuta 8 llamadas ya que lee una vez todo en un buffer.

Pregunta 56.
    El 0 escribe la salida en ascii
    El 1 escribe la salida en formato integer

Pregunta 57.
    El programa interpreta la entrada en formato integer por lo tanto cuando le pasas la entrada en ascii funciona incorrectamente.

Pregunta 59.

    ./showCpuTime.sh ./es5 ./es1 ha mostrado por salida:

    CMD                         %CPU     TIME
    ./es5                       99.6 00:01:04
    ./es1                        0.0 00:00:00
    ./es5                       99.6 00:01:06
    ./es1                        0.0 00:00:00
    ./es5                       99.7 00:01:08
    ./es1                        0.0 00:00:00
    ./es5                       99.7 00:01:10
    ./es1                        0.0 00:00:00
    ./es5                       99.7 00:01:12
    ./es1                        0.0 00:00:00
    ./es5                       99.7 00:01:14
    ./es1                        0.0 00:00:00

    La diferencia es que el ./es1 ha gastado 0s de CPU y ./es5 ha usado un 99.7 de la CPU durante el tiempo de ejecuci√≥n del programa.

    Eso quiere decir que la llamada al sistema read ha hecho que es1 se bloquee y por lo tanto ha dejado de usar la cpu. En cambio, la espera activa del ./es5 ha estado funcionando casi todo el rato.

    es1 para en el read.

    es5 para en while(1);


Pregunta 61.

    No se ejecutaria interrumpe el programa.
